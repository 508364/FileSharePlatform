# 工作流名称：多平台自动构建与发布
name: Enhanced Multi-Platform Build and Release

# 触发条件：推送到main分支、PR到main分支或手动触发
on:
    push:
      branches: [ main ]
    pull_request:
      branches: [ main ]
    workflow_dispatch:

# 环境变量配置
env:
    PROJECT_NAME: FileSharePlatform
    NETIFACES_VERSION: 0.11.0
    PYTHON_VERSION: '3.9'

jobs:
  get_version:
    runs-on: ubuntu-latest
    outputs:
      VERSION: ${{ steps.get_version.outputs.VERSION }}
    steps:
    - uses: actions/checkout@v4
    
    - name: Read version from server.py
      id: get_version
      run: |
        import re
        try:
            with open('server.py', 'r', encoding='utf-8') as f:
                content = f.read()
            version = re.search(r"'app_version'\s*:\s*['\"]([^'\"]+)['\"]", content).group(1)
            print(f"::set-output name=VERSION::{version}")
        except Exception as e:
            print(f"Error reading version: {e}")
            # 使用默认版本作为备选
            print(f"::set-output name=VERSION::1.0.0")
      shell: python
  
  build:
    needs: get_version
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
    steps:
    - uses: actions/checkout@v4
      with:
        submodules: 'recursive'
        fetch-depth: 0
    
    - name: Set up Python ${{ env.PYTHON_VERSION }}
      uses: actions/setup-python@v5
      with:
        python-version: ${{ env.PYTHON_VERSION }}
        cache: 'pip'
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip wheel setuptools
        
        # 所有平台特殊处理netifaces安装
        if [ "${{ matrix.os }}" = "windows-latest" ]; then
          # Windows平台使用项目中预编译的whl文件
          echo "Installing netifaces from project's precompiled wheel file"
          
          # 输出当前工作目录以帮助调试 (跨平台兼容)
          if [ "${{ matrix.os }}" = "windows-latest" ]; then
            echo "Current working directory: %CD%" || true
            CURRENT_DIR=%CD%
          else
            echo "Current working directory: $PWD" || true
            CURRENT_DIR=$PWD
          fi

          # 列出netifaces文件夹内容以帮助调试
          echo "Contents of netifaces-${{ env.NETIFACES_VERSION }} folder:" || true
          if [ "${{ matrix.os }}" = "windows-latest" ]; then
            # Windows命令
            dir netifaces-${{ env.NETIFACES_VERSION }} || true
            # 额外检查绝对路径
            echo "Checking absolute path: %CD%\\netifaces-${{ env.NETIFACES_VERSION }}" || true
            dir "%CD%\\netifaces-${{ env.NETIFACES_VERSION }}" || true
          else
            # Linux/Mac命令
            ls -la netifaces-${{ env.NETIFACES_VERSION }} || true
          fi

          # 定义whl文件名
          WHL_FILE_NAME="netifaces-${{ env.NETIFACES_VERSION }}-cp${{ env.PYTHON_VERSION }}-cp${{ env.PYTHON_VERSION }}-win_amd64.whl"
          echo "Looking for wheel file: $WHL_FILE_NAME" || true

          # 检查项目中的whl文件是否存在 (使用变量和绝对路径)
          INSTALL_SUCCESS=false
          if [ "${{ matrix.os }}" = "windows-latest" ]; then
            # Windows路径检查
            if [ -f "%CD%\\netifaces-${{ env.NETIFACES_VERSION }}\\$WHL_FILE_NAME" ]; then
              echo "Found project's precompiled wheel file at Windows absolute path"
              pip install "%CD%\\netifaces-${{ env.NETIFACES_VERSION }}\\$WHL_FILE_NAME"
              INSTALL_SUCCESS=true
            elif [ -f "netifaces-${{ env.NETIFACES_VERSION }}\\$WHL_FILE_NAME" ]; then
              echo "Found project's precompiled wheel file with Windows relative path"
              pip install "netifaces-${{ env.NETIFACES_VERSION }}\\$WHL_FILE_NAME"
              INSTALL_SUCCESS=true
            elif [ -f "$WHL_FILE_NAME" ]; then
              echo "Found wheel file in current directory"
              pip install "$WHL_FILE_NAME"
              INSTALL_SUCCESS=true
            fi
          else
            # Linux/Mac路径检查
            if [ -f "$PWD/netifaces-${{ env.NETIFACES_VERSION }}/$WHL_FILE_NAME" ]; then
              echo "Found project's precompiled wheel file at Linux/Mac absolute path"
              pip install "$PWD/netifaces-${{ env.NETIFACES_VERSION }}/$WHL_FILE_NAME"
              INSTALL_SUCCESS=true
            elif [ -f "netifaces-${{ env.NETIFACES_VERSION }}/$WHL_FILE_NAME" ]; then
              echo "Found project's precompiled wheel file with Linux/Mac relative path"
              pip install "netifaces-${{ env.NETIFACES_VERSION }}/$WHL_FILE_NAME"
              INSTALL_SUCCESS=true
            elif [ -f "$WHL_FILE_NAME" ]; then
              echo "Found wheel file in current directory"
              pip install "$WHL_FILE_NAME"
              INSTALL_SUCCESS=true
            fi
          fi

          # 如果上述路径都没找到，尝试使用备用路径
          if [ "$INSTALL_SUCCESS" = false ]; then
            echo "Couldn't find netifaces wheel in standard paths, trying fallback..." || true
            
            # 列出所有可能的whl文件以帮助调试
            if [ "${{ matrix.os }}" = "windows-latest" ]; then
              echo "Searching for netifaces wheel files in Windows..." || true
              dir /s /b *netifaces*.whl || true
            else
              echo "Searching for netifaces wheel files in Linux/Mac..." || true
              find . -name "*netifaces*.whl" || true
            fi
            
            # 尝试使用备用路径格式
            if [ -f "netifaces-${{ env.NETIFACES_VERSION }}-cp${{ env.PYTHON_VERSION }}-cp${{ env.PYTHON_VERSION }}-win_amd64.whl" ]; then
              echo "Found fallback wheel file"
              pip install netifaces-${{ env.NETIFACES_VERSION }}-cp${{ env.PYTHON_VERSION }}-cp${{ env.PYTHON_VERSION }}-win_amd64.whl
              INSTALL_SUCCESS=true
            else
              # 作为最后的后备方案，尝试从PyPI安装
              echo "Fallback wheel not found, trying to install from PyPI..." || true
              pip install --only-binary :all: --verbose --timeout=180 netifaces==${{ env.NETIFACES_VERSION }}
              # 检查PyPI安装是否成功
              if python -c "import netifaces" 2>/dev/null; then
                INSTALL_SUCCESS=true
              fi
            fi
          fi

          # 验证安装
          if [ "$INSTALL_SUCCESS" = true ]; then
            python -c "import netifaces; print('netifaces version:', netifaces.__version__)" || echo "netifaces installation verification failed"
          else
            echo "netifaces installation failed after all attempts" && exit 1
          fi
          elif [ -f "netifaces-${{ env.NETIFACES_VERSION }}\\$WHL_FILE_NAME" ]; then
            echo "Found project's precompiled wheel file with backslash path"
            pip install "netifaces-${{ env.NETIFACES_VERSION }}\\$WHL_FILE_NAME"
          elif [ -f "netifaces-${{ env.NETIFACES_VERSION }}/$WHL_FILE_NAME" ]; then
            echo "Found project's precompiled wheel file with forward slash path"
            pip install "netifaces-${{ env.NETIFACES_VERSION }}/$WHL_FILE_NAME"
          elif [ -f "$WHL_FILE_NAME" ]; then
            echo "Found wheel file in current directory"
            pip install "$WHL_FILE_NAME"
          else
            echo "Project's precompiled wheel file not found in any of the checked paths"
            # 尝试使用备用路径
            if [ -f "netifaces-${{ env.NETIFACES_VERSION }}-cp${{ env.PYTHON_VERSION }}-cp${{ env.PYTHON_VERSION }}-win_amd64.whl" ]; then
              pip install netifaces-${{ env.NETIFACES_VERSION }}-cp${{ env.PYTHON_VERSION }}-cp${{ env.PYTHON_VERSION }}-win_amd64.whl
            else
              # 作为最后的后备方案，尝试从PyPI安装
              pip install --only-binary :all: --verbose --timeout=180 netifaces==${{ env.NETIFACES_VERSION }}
            fi
          fi
          
          # 验证安装
          python -c "import netifaces; print('netifaces version:', netifaces.__version__)" || { echo "netifaces installation failed"; exit 1; }
        elif [ "${{ matrix.os }}" = "ubuntu-latest" ]; then
          # Linux平台安装编译依赖并尝试从源码编译
          sudo apt-get update && sudo apt-get install -y gcc python3-dev
          pip install --no-binary :all: --verbose --timeout=120 netifaces==${{ env.NETIFACES_VERSION }}
        elif [ "${{ matrix.os }}" = "macos-latest" ]; then
          # macOS平台安装编译依赖并尝试从源码编译
          brew install gcc || true  # 忽略brew安装失败
          pip install --no-binary :all: --verbose --timeout=120 netifaces==${{ env.NETIFACES_VERSION }}
        fi
        
        # 安装剩余依赖
        pip install -r requirements.txt
        pip install pyinstaller pytest
      shell: bash
    
    - name: Run tests
      run: |
        # 检查是否存在测试目录或测试文件
        if [ -d "tests" ] || ls -la | grep -q 'test_.*\.py'; then
          echo "Running tests..."
          pytest -v || echo "Tests failed but continuing build"
        else
          echo "No tests found, skipping pytest"
        fi
      continue-on-error: true
    
    - name: Build with PyInstaller
      timeout-minutes: 90
      run: |
        # 根据不同平台设置路径分隔符和优化参数
        if [ "${{ matrix.os }}" = "windows-latest" ]; then
          separator=";"
          os_suffix="windows"
          # Windows平台优化参数 - 禁用windowed模式以便查看输出，增加详细日志
          optimization_flags="--log-level=DEBUG --noupx --debug=imports"
        else
          separator=":"
          if [ "${{ matrix.os }}" = "ubuntu-latest" ]; then
            os_suffix="linux"
          else
            os_suffix="macos"
          fi
          optimization_flags="--log-level=INFO"
        fi
        
        # 输出构建环境信息
        echo "Building on ${{ matrix.os }}"
        echo "Python version: $(python --version)"
        echo "PyInstaller version: $(pyinstaller --version)"
        
        # 构建命令
        pyinstaller --onefile \
                    --name ${{ env.PROJECT_NAME }}-${os_suffix}-v${{ needs.get_version.outputs.VERSION }} \
                    --add-data "templates${separator}templates" \
                    --add-data "static${separator}static" \
                    --icon=favicon.ico \
                    --clean \
                    ${{ matrix.os == 'windows-latest' && '' || '--windowed' }} \
                    $optimization_flags \
                    server.py
        
        # 输出构建结果信息
        echo "Build complete. Output directory contents:" 
        ls -la dist/
      shell: bash
    
    # Windows平台特定步骤
    - name: Windows specific fixes
      if: matrix.os == 'windows-latest'
      run: |
        # Windows不需要chmod，通过扩展名识别可执行文件
        # 输出构建详情以便调试
        echo "Windows build details:" 
        echo "- Output directory: dist/"
        echo "- Built file: ${{ env.PROJECT_NAME }}-windows-v${{ needs.get_version.outputs.VERSION }}.exe"
        ls -la dist/
      shell: bash
    
    - name: List build output
      run: |
        ls -la dist/
      shell: bash
    
    - name: Upload build artifact
      uses: actions/upload-artifact@v4
      with:
        name: ${{ matrix.os }}-build
        path: |
          dist/${{ env.PROJECT_NAME }}-*
          !dist/*dSYM
        if-no-files-found: error
    
    - name: Clean up build files
      run: |
        rm -rf build/
        rm -rf __pycache__/
      shell: bash
  
  release:
    needs: [build, get_version]
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 0
    
    - name: Set version from get_version job
      run: |
        echo "VERSION=${{ needs.get_version.outputs.VERSION }}" >> $GITHUB_ENV
        echo "PROJECT_NAME=${{ env.PROJECT_NAME }}" >> $GITHUB_ENV
      shell: bash
    
    - name: Download all build artifacts
      uses: actions/download-artifact@v4
      with:
        path: dist
    
    - name: Verify downloaded artifacts
      run: |
        echo "Verifying build artifacts..."
        ls -laR dist/
        # 检查主要平台的构建产物是否存在
        # 检查所有平台的构建产物是否存在
        if [ ! -f "dist/ubuntu-latest-build/${{ env.PROJECT_NAME }}-linux-v${{ needs.get_version.outputs.VERSION }}" ] && \
           [ ! -f "dist/windows-latest-build/${{ env.PROJECT_NAME }}-windows-v${{ needs.get_version.outputs.VERSION }}.exe" ] && \
           [ ! -f "dist/macos-latest-build/${{ env.PROJECT_NAME }}-macos-v${{ needs.get_version.outputs.VERSION }}" ]; then
          echo "Error: Build artifacts not found!"
          exit 1
        fi
      shell: bash
    
    - name: Create Release
      uses: softprops/action-gh-release@v2
      with:
        name: Release v${{ needs.get_version.outputs.VERSION }}
        tag_name: v${{ needs.get_version.outputs.VERSION }}
        files: |
          dist/ubuntu-latest-build/${{ env.PROJECT_NAME }}-linux-v${{ needs.get_version.outputs.VERSION }}
          dist/windows-latest-build/${{ env.PROJECT_NAME }}-windows-v${{ needs.get_version.outputs.VERSION }}.exe
          dist/macos-latest-build/${{ env.PROJECT_NAME }}-macos-v${{ needs.get_version.outputs.VERSION }}
        generate_release_notes: true
        draft: false
        prerelease: false
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
